The RUX86 Specification
=======================

RUX86 is a 32-bit signed integer-only subset of the Intel
IA-32 machine architecture. The RUX86 instruction set is a
small subset of the the full X86 32-bit instruction set. However, this
subset is sufficiently large enough to write interesting programs and
as a compilation target for the course projects.

This document is a reference manual of the RUX86 instruction
and the machine model. The course infrastructure provides OCaml
interfaces for manipulating RUX86 programs and tools for
assembling RUX86 programs into executables. The full X86
architecture manual can be found in the Intel web page at
http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html


RUX86 Machine State
===================

The RUX86 machine state consists of eight 32-bit registers,
three condition flags, and a memory consisting of 2^32 bytes (though
for the purposes of our interpreter we model only a 4096 byte memory
consisting of 1024 32-bit words). In a real X86 machine there is also
a program counter register EIP that holds a pointer to the current
instruction. EIP can only be manipulated indirectly through
control-flow instructions like Jmp. (The EIP needs special treatment
in the interpreter)

Register file
-------------

The eight 32-bit registers in RUX86 and their common uses in
the full X86 architecture are given below. In RUX86, most of
the registers can be used for general purpose calculation, but some
RUX86 instructions make special use of some of the registers;
see the instruction descriptions below.

Register and its common use is described below. However the compiler
is free to use the register for other purposes.


EAX         General purpose accumulator
EBX         Base register, pointer to data
ECX         Counter register for strings and loops
EDX         Data register for I/O
ESI         Pointer register, string source register
EDI         Pointer register, string destination register
EBP         Base pointer, points to the stack frame
ESP         Stack pointer, points to the value at the top of the stack

Condition flags
===============

The X86 architecture provides conditional branch and conditional move
instructions. The processor maintains a set of bit-sized flags to keep
track of conditions arising from arithmetic and comparison
operations. These condition flags are tested by the conditional jump
and move instructions; the flags are set by the arithmetic
instructions. X86lite provides only three condition flags (the full
X86 architecture has several more).

Condition Flag
--------------

Description

OF      

Overflow: set when the result is too big or too small to fit in a
32-bit value and cleared otherwise. This is overflow/underflow for
signed (two's complement) 32-bit arithmetic.

SF      

Sign: equal to the most significant bit of the result (0=positive,
1=negative)

ZF      

Zero: set if the result is 0 and cleared otherwise Memory, addresses,
and the stack

The X86 32-bit machine memory consists of 2^32 bytes numbered
0x00000000 through 0xffffffff. RUX86 treats the memory as
consisting of 32-bit (4-byte) words; that is, we can think of it as an
int32 array called Mem indexed by 32-bit word-aligned addresses. As a
consequence, all valid memory addresses are evenly divisible by 4.

By convention on X86 machines, the program stack starts at the high
addresses of virtual memory and grows toward the low addresses. The
register ESP points to the value at the top of the stack. Instructions
like push and pop increment and decrement ESP as needed to maintain
this invariant.

RUX86 Operands and Condition Codes
==================================

This section describes the RUX86 instruction set.

Operands
--------

RUX86 instructions manipulate data stored in memory or in
registers. The values operated on by a given instruction are described
by operands, which are constant values like integers and statically
known memory addresses, or dynamic values such as the contents of a
register or a computed memory address.

Operands can take one of four forms, described below:

Operand kind
------------
Description

(1) Imm : int32 
 
     An immediate, constant value of size 32-bits.

(2) Lbl : lbl       

     A label value generated by the compiler. The assembler and linker
     resolve this to a constant memory address at load time. Label
     values typically denote targets of Jmp or Call instructions.

(3) Reg : reg       

     One of the eight machine registers. The value of a register is
     its contents.

(4) Ind : ind       
     
     An indirect address. The type ind consists of three optional
components: [base : reg] [index : reg, scale : int32] [disp : (int32 |
Label)]

The effective address denoted by an indirect address is calculated by:
addr(Ind) = base + (index * scale) + disp.

In the formula above, a missing optional component's value is 0.
The index component cannot be ESP.

When an Ind operand is used as a value (not a location) the operand
denotes Mem[addr(Ind)], the contents of the machine memory at the
effective address denoted by Ind.

Condition codes
---------------

The RUX86's Cmp SRC1 SRC2 instruction is used to compare two
32-bit operands (SRC1 and SRC2). It works by subtracting SRC2 from
SRC1, setting the condition flags according to the result (the actual
result of the subtraction is ignored).

The X86lite conditional branch (J) and conditional set (Setb)
instructions specify condition codes that look at the condition flags
to determine whether or not the condition is satisfied. The eight
condition codes and their interpretation in terms of condition flags
are given below:

Condition code
--------------

Description

(1) Eq      

Equals: This condition holds when ZF is set. (Intuitively SRC1 = SRC2
when SRC1 - SRC2 = 0.)

(2) Zero    

Zero: This condition holds when ZF is set. (This condition is the same
as Eq.)

(3)  NotEq 

Not equals: This condition holds when ZF is not set.

(4) NotZero 

Not zero: This condition holds when ZF is not set. (This condition is
the same as NotEq.)

(5) Slt     

(Signed) less than: This condition holds when SF does not equal
OF. Equivalently, this condition holds when ((SF = 1 and OF = 0) or
(SF = 0 and OF = 1)). The first case holds when the result of SRC1 -
SRC2 is negative and there has been no overflow, the second case holds
when the result of SRC1 - SRC2 is positive and there has been an
overflow.

(6) Sge     

(Signed) greater than or equal: This condition holds when SF equals
OF. This is the negation of the conditions for Slt (see above).

(7) Sle     

(Signed) less than or equal: This condition holds when (SF is not
equal to OF) or ZF is set. This is just (Slt or Equal).

(8) Sgt     

(Signed) greater than: This condition is just the negation of Sle.


RUX86 Instructions
==================

There are 21 instructions in the RUX86 architecture. Together,
they provide basic signed arithmetic over 32-bit integers, logical
operations, data movement between registers and memory, and
control-flow operations for branches and jumps. In x86, instructions
that involve two operands must not use two memory (Ind) operands.

When an operand appears on the right-hand side of the <-- symbol in
the instruction descriptions below, it is interpreted as a value,
computed as described above. When an operand appears on the left-hand
side of an <-- symbol, it is interpreted as a location. The location
of a register operand is the register itself; the location of an Ind
operand is Mem[Ind]. Immediate values and labels do not denote valid
locations.

The instruction descriptions state which condition flags are affected
by the operation. The presence of the symbols SF, ZF, and OF indicate
that these flags are set as described in the condition flags
section. A * next to a flag indicates special handling. Note that
overflow conditions for all arithmetic operations are defined per
instruction.

The instruction description uses the ATT syntax, which is the common
format for assembly on Linux systems with GNU assembler and tools like
objdump.


Arithmetic Instructions
-----------------------

Instruction
-----------


(1) Neg DEST 
    
    Operation description: Two's complement negation. 

    Semantics: DEST <--  -DEST 

    Flags affected: SF ZF OF* 
    
    Details:  Flag OF is set if DEST is MIN_INT


(2) Add SRC DEST

    Operation description: Signed integer addition.

    Semantics: DEST <--  DEST +32 SRC 

    Flags affected: SF ZF OF*  

    Details: Let D64 be the 64-bit sign extension of DEST and S64 be
    the 64-bit sign extension of SRC. The result R32 = DEST +32 SRC is
    the 32-bit truncation of R64, which is obtained by 64-bit addition
    R64 = D64 +64 S64. Flag OF is set when S64 and D64 have the same
    sign but R32 and S64 do not.


(3) Sub SRC DEST 

    Operation description: Signed integer subtraction.

    Semantics: DEST <-- DEST -32 SRC 

    Flags affected : SF ZF OF* 

    Details: This operation can be computed using arithmetic negation
    and addition. Let D64 be the 64-bit sign extension of DEST and S64
    be the 64-bit sign extension of SRC. The result R32 = DEST -32 SRC
    is the 32-bit truncation of R64, which is obtained by the 64-bit
    computation R64 = D64 +64 -S64. Flag OF is set when D64 and -S64
    have the same sign but R32 and -S64 do not or when SRC = MIN_INT.


(4) Imul SRC Reg 

    Operation description: Signed integer multiply.

    Semantics: Reg <-- Reg *32 SRC 

    Flags affected: SF* ZF* OF*  

    Details: Let D64 be the 64-bit sign extension of Reg and S64 be
    the 64-bit sign extension of SRC. The result R32 = Reg *32 SRC is
    the 32-bit truncation of R64, which is obtained by 64-bit
    multiplication R64 = D64 *64 S64. Flag OF is set when R64 cannot
    be represented as a 32-bit sign-extended integer. Flags ZF and SF
    are undefined.


Logic Instructions
------------------

(5) Not DEST        

    Operation description: One's complement (logical) negation.

    Semantics: DEST <-- not DEST

    Flags affected: None

(6) And SRC DEST    
      
    Operation description:  Logical AND.
    
    Semantics: DEST <-- DEST AND SRC     

    Flags affected: SF ZF OF* 

    Details: Flag OF is always set to 0.

(7) Or SRC DEST     

    Operation description: Logical OR. 
    
    Semantics: DEST <-- DEST OR SRC      
    
    Flags affected: SF ZF OF* 
    
    Details: Flag OF is always set to 0.

(8) Xor SRC DEST    

    Operation description: Logical XOR. 
    
    Semantics: DEST â† DEST XOR SRC     
    
    Flags affected: SF ZF OF* 

    Details: Flag OF is always set to 0.


Bit-manipulation Instructions
-----------------------------

(9) Sar AMT DEST   

    Operation description: Arithmetic shift DEST right by AMT,
    replicating the sign bit for the vacated spaces.

    Semantics: DEST <--  DEST >> AMT      

    Flags affected: SF* ZF* OF*      

    Details: AMT must be a Imm or ECX operand. If AMT = 0 flags are
    unaffected. Otherwise the flags SF and ZF are set as usual. The OF
    flag is set to 0 if the shift amount is 1 (and is otherwise
    unaffected).


(10) Shl AMT DEST

    Operation description: Bitwise shift DEST left by AMT.

    Semantics: DEST <-- DEST << AMT      

    Flags affected: SF* ZF* OF*      

    Details: AMT must be a Imm or ECX operand. If AMT = 0 flags are
    unaffected. Otherwise, flags SF and ZF are set as usual. OF is set
    if the top two bits of DEST are different and the shift amount is
    1 (and is otherwise unaffected).


(11) Shr AMT DEST

     Operation description: Bitwise shift DEST right by AMT inserting
     0's for the vacated spaces.

     Semantics: DEST <-- DEST >>> AMT     

     Flags affected: SF* ZF* OF*     

     Details:  AMT must be a Imm or ECX operand. Flags are set
     as in the Shl instruction, where OF is set to the
     most-significant bit of the original operand if the shift amount
     is 1 (and is otherwise unaffected).

(12) Setb CC DEST    

     Operation description: Set byte based on condition code.

     Semantics: DEST's lower byte <-- if CC then 1 else 0 

     Flags affected : NONE

     Details: If condition code CC holds in the current state, move 1
     into the lower byte of DEST; otherwise move 0 into the lower
     byte.


Data-movement Instructions
--------------------------


(13) Lea Ind DEST

     Operation description: Load Effective Address

     Semantics:    DEST <-- addr(Ind)      

     Flags affected: NONE
     
     Details: Load effective address of Ind, which must be an operand
     of type ind (see operands). This instruction calculates a pointer
     into memory and stores it in DEST. The compiler may use this
     instruction to perfom certain arithmetic computations. 

(14) Mov SRC DEST

     Operation description: Copy the value of SRC to the location
     denoted by DEST

     Semantics: DEST <-- SRC

     Flags affected: NONE


(15) Push SRC 

     Operation description: Push a 32-bit value onto the stack:
     decrement ESP by 4 to allocate the new stack slot and then store
     SRC in the resulting memory address.

     Semantics:  ESP <-- ESP - 4; 
                 Mem[ESP] <- SRC

     Flags affected: NONE

 
(16) Pop DEST 

     Operation description: Pop the top of the stack into DEST: Load
     the value pointed to by ESP from memory and then increment ESP by
     4.

     Semantics: DEST <-- Mem[ESP]; 
                ESP <-- ESP + 4 

     Flags affected: NONE

    

Control-flow related Instructions
---------------------------------

(17) Cmp SRC2 SRC1  

     Operation description: Compare SRC1 to SRC2 by setting all
     condition flags as though the instruction Sub SRC1 SRC2 was
     executed. Does not change register or memory contents.


      Semantics: _ <-- SRC1 -32 SRC2 

      Flags affected: SF* ZF* OF*     

(18) Jmp SRC  
     
     Operation description: Jump to the machine instruction at the
     address given by the value of SRC. Sets the program counter.
     
     Semantics: EIP <-- SRC

     Flags affected:  NONE

(19) Call SRC 

     Operation description: Call a procedure: Push the program counter
     to the stack (decrementing ESP) and then jump to the machine
     instruction at the address given by the value of SRC.

     Semantics: Push EIP;
                EIP <--  SRC     
                
     Flags affected: NONE



(20) Ret 

     Operation description: Return from a procedure: Pop the current
     top of the stack into EIP (incrementing ESP); this instruction
     effectively jumps to the address at the top of the stack.

     Semantics: POP EIP

     Flags affected: NONE
     
(21) J CC Clbl 
     
     Operation description: Conditional jump; If the condition code CC
     holds in the current state, set EIP to Lbl otherwise set EIP to
     the next instruction (i.e. fallthrough).

     Semantics: EIP <-- if CC then Lbl else *

     Flags affected: NONE
